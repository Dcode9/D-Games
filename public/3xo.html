<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3XO: Three-Player Tic-Tac-Toe</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        /* Custom styles for player symbols for better visual distinction */
        .player-triangle { color: #22c55e; } /* green-500 */
        .player-x { color: #3b82f6; } /* blue-500 */
        .player-o { color: #ef4444; } /* red-500 */

        /* Animation for winning cells */
        .win-cell {
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0%, 100% {
                transform: scale(1);
                opacity: 1;
            }
            50% {
                transform: scale(1.1);
                opacity: 0.9;
            }
        }
    </style>
</head>
<body class="bg-gray-900 text-white flex flex-col items-center justify-center min-h-screen p-4">

    <div class="w-full max-w-md text-center">
        <h1 class="text-3xl sm:text-4xl md:text-5xl font-bold mb-2">3XO Game</h1>
        <p class="text-gray-400 mb-6">First to get 4 in a row wins!</p>

        <!-- Game Status Display -->
        <div id="status" class="text-xl sm:text-2xl font-medium mb-6 h-8 transition-all duration-300"></div>

        <!-- Game Board -->
        <div id="board" class="grid grid-cols-5 gap-2 bg-gray-800 p-3 rounded-lg shadow-2xl">
            <!-- Cells will be generated by JavaScript -->
        </div>

        <!-- Restart Button -->
        <button id="restartButton" class="mt-8 bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-6 sm:py-3 sm:px-8 rounded-lg shadow-lg transition-transform transform hover:scale-105">
            Restart Game
        </button>
    </div>

    <script>
        // --- DOM Elements ---
        const boardElement = document.getElementById('board');
        const statusElement = document.getElementById('status');
        const restartButton = document.getElementById('restartButton');

        // --- Game Constants ---
        const BOARD_SIZE = 5;
        const WIN_CONDITION = 4;
        const PLAYERS = [
            { symbol: 'â–³', className: 'player-triangle' },
            { symbol: 'X', className: 'player-x' },
            { symbol: 'O', className: 'player-o' }
        ];

        // --- Game State ---
        let boardState;
        let currentPlayerIndex;
        let gameActive;

        // --- Game Logic ---

        /**
         * Initializes or resets the game to its starting state.
         */
        function initializeGame() {
            boardState = Array(BOARD_SIZE).fill(null).map(() => Array(BOARD_SIZE).fill(null));
            currentPlayerIndex = 0;
            gameActive = true;
            
            // Clear the board UI and recreate cells
            boardElement.innerHTML = '';
            for (let row = 0; row < BOARD_SIZE; row++) {
                for (let col = 0; col < BOARD_SIZE; col++) {
                    const cell = document.createElement('div');
                    cell.dataset.row = row;
                    cell.dataset.col = col;
                    // Use aspect-square for perfect squares and responsive font sizes
                    cell.classList.add(
                        'aspect-square', // <-- This is the key change for even spacing
                        'flex', 'items-center', 'justify-center', 
                        'text-4xl', 'sm:text-5xl',
                        'font-bold', 'bg-gray-700', 'rounded-md', 'cursor-pointer', 
                        'transition-all', 'duration-200', 'hover:bg-gray-600'
                    );
                    cell.addEventListener('click', handleCellClick);
                    boardElement.appendChild(cell);
                }
            }
            updateStatus();
        }

        /**
         * Handles the logic when a player clicks on a cell.
         * @param {MouseEvent} event - The click event from the cell.
         */
        function handleCellClick(event) {
            if (!gameActive) return;

            const cell = event.target;
            const row = parseInt(cell.dataset.row);
            const col = parseInt(cell.dataset.col);

            // Check if the cell is already taken
            if (boardState[row][col]) {
                return;
            }

            // Update state and UI
            const currentPlayer = PLAYERS[currentPlayerIndex];
            boardState[row][col] = currentPlayer.symbol;
            cell.textContent = currentPlayer.symbol;
            cell.classList.add(currentPlayer.className);
            cell.classList.remove('hover:bg-gray-600'); // Disable hover effect after click

            // Check for a winner or a draw
            if (checkWin(row, col)) {
                gameActive = false;
                statusElement.innerHTML = `Player <span class="${currentPlayer.className}">${currentPlayer.symbol}</span> Wins!`;
            } else if (isDraw()) {
                gameActive = false;
                statusElement.textContent = "It's a Draw!";
            } else {
                // Switch to the next player
                currentPlayerIndex = (currentPlayerIndex + 1) % PLAYERS.length;
                updateStatus();
            }
        }

        /**
         * Updates the status display to show whose turn it is.
         */
        function updateStatus() {
            const currentPlayer = PLAYERS[currentPlayerIndex];
            statusElement.innerHTML = `Player <span class="${currentPlayer.className}">${currentPlayer.symbol}</span>'s Turn`;
        }

        /**
         * Checks if the board is full, resulting in a draw.
         * @returns {boolean} - True if the game is a draw, false otherwise.
         */
        function isDraw() {
            return boardState.flat().every(cell => cell !== null);
        }
        
        /**
         * Checks all directions from the last move to see if it resulted in a win.
         * @param {number} row - The row of the last move.
         * @param {number} col - The column of the last move.
         * @returns {boolean} - True if a win is detected, false otherwise.
         */
        function checkWin(row, col) {
            const symbol = boardState[row][col];
            const directions = [
                { r: 0, c: 1 },  // Horizontal
                { r: 1, c: 0 },  // Vertical
                { r: 1, c: 1 },  // Diagonal (down-right)
                { r: 1, c: -1 }  // Diagonal (down-left)
            ];

            for (const dir of directions) {
                const count = 1 + countInDirection(row, col, symbol, dir) + countInDirection(row, col, symbol, { r: -dir.r, c: -dir.c });
                if (count >= WIN_CONDITION) {
                    highlightWinningCells(row, col, symbol, dir);
                    return true;
                }
            }
            return false;
        }

        /**
         * Counts consecutive symbols in a single direction from a starting point.
         * @param {number} r - Starting row.
         * @param {number} c - Starting column.
         * @param {string} symbol - The player's symbol to count.
         * @param {{r: number, c: number}} dir - The direction to check {row_change, col_change}.
         * @returns {number} - The number of consecutive symbols found.
         */
        function countInDirection(r, c, symbol, dir) {
            let count = 0;
            let nextR = r + dir.r;
            let nextC = c + dir.c;
            while (
                nextR >= 0 && nextR < BOARD_SIZE &&
                nextC >= 0 && nextC < BOARD_SIZE &&
                boardState[nextR][nextC] === symbol
            ) {
                count++;
                nextR += dir.r;
                nextC += dir.c;
            }
            return count;
        }

        /**
         * Highlights the winning cells on the board.
         */
        function highlightWinningCells(row, col, symbol, dir) {
            const winningCells = [{r: row, c: col}];
            
            // Check in the primary direction
            let nextR = row + dir.r;
            let nextC = col + dir.c;
            while (nextR >= 0 && nextR < BOARD_SIZE && nextC >= 0 && nextC < BOARD_SIZE && boardState[nextR][nextC] === symbol) {
                winningCells.push({r: nextR, c: nextC});
                nextR += dir.r;
                nextC += dir.c;
            }
            
            // Check in the opposite direction
            nextR = row - dir.r;
            nextC = col - dir.c;
            while (nextR >= 0 && nextR < BOARD_SIZE && nextC >= 0 && nextC < BOARD_SIZE && boardState[nextR][nextC] === symbol) {
                winningCells.push({r: nextR, c: nextC});
                nextR -= dir.r;
                nextC -= dir.c;
            }

            winningCells.forEach(cellCoord => {
                const cellElement = document.querySelector(`[data-row='${cellCoord.r}'][data-col='${cellCoord.c}']`);
                if(cellElement) {
                    cellElement.classList.add('bg-yellow-500', 'text-gray-900', 'win-cell');
                }
            });
        }


        // --- Event Listeners ---
        restartButton.addEventListener('click', initializeGame);

        // --- Initial Game Start ---
        window.onload = initializeGame;
    </script>
</body>
</html>
