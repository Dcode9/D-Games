<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Orbit Guard</title>
    <style>
        body { margin: 0; background: #0b0b14; overflow: hidden; touch-action: none; font-family: 'Arial', sans-serif;}
        canvas { display: block; }
        #ui { position: absolute; top: 20px; width: 100%; text-align: center; color: #44aaff; font-size: 24px; pointer-events: none; }
    </style>
</head>
<body>
    <div id="ui">Protect the Core</div>
    <canvas id="c"></canvas>
    <script>
        const c = document.getElementById('c');
        const ctx = c.getContext('2d');
        let w, h;

        let angle = 0;
        let score = 0;
        let health = 100;
        let gameRunning = true;

        const CORE_RADIUS = 40;
        const ORBIT_RADIUS = 100;
        const SHIELD_SIZE = 0.8; // Radians

        let meteors = [];
        let particles = [];

        function resize() {
            w = c.width = window.innerWidth;
            h = c.height = window.innerHeight;
        }
        window.addEventListener('resize', resize);
        resize();

        // Controls
        window.addEventListener('mousemove', e => {
            const dx = e.clientX - w/2;
            const dy = e.clientY - h/2;
            angle = Math.atan2(dy, dx);
        });

        window.addEventListener('touchmove', e => {
            const dx = e.touches[0].clientX - w/2;
            const dy = e.touches[0].clientY - h/2;
            angle = Math.atan2(dy, dx);
        }, {passive: false});

        window.addEventListener('click', () => { if(!gameRunning) reset(); });

        class Meteor {
            constructor() {
                const spawnAngle = Math.random() * Math.PI * 2;
                const dist = Math.max(w, h) / 2 + 50;
                this.x = w/2 + Math.cos(spawnAngle) * dist;
                this.y = h/2 + Math.sin(spawnAngle) * dist;
                this.speed = 1.5 + Math.random();
                this.rad = 5 + Math.random() * 10;
                
                // Velocity pointing to center
                const angleToCenter = Math.atan2(h/2 - this.y, w/2 - this.x);
                this.vx = Math.cos(angleToCenter) * this.speed;
                this.vy = Math.sin(angleToCenter) * this.speed;
                this.color = `hsl(${Math.random()*60 + 10}, 80%, 60%)`; // Orange/Red/Yellow
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
            }

            draw() {
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.rad, 0, Math.PI*2);
                ctx.fill();
            }
        }

        class Particle {
            constructor(x, y, color) {
                this.x = x; this.y = y; this.color = color;
                this.vx = (Math.random() - 0.5) * 5;
                this.vy = (Math.random() - 0.5) * 5;
                this.life = 1;
            }
            update() {
                this.x += this.vx; this.y += this.vy; this.life -= 0.05;
            }
            draw() {
                ctx.globalAlpha = Math.max(0, this.life);
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x, this.y, 3, 3);
                ctx.globalAlpha = 1;
            }
        }

        function reset() {
            meteors = [];
            particles = [];
            score = 0;
            health = 100;
            gameRunning = true;
            document.getElementById('ui').innerText = "Protect the Core";
        }

        function createExplosion(x, y, color) {
            for(let i=0; i<10; i++) particles.push(new Particle(x, y, color));
        }

        function loop() {
            requestAnimationFrame(loop);
            
            // Trails
            ctx.fillStyle = 'rgba(11, 11, 20, 0.3)';
            ctx.fillRect(0, 0, w, h);

            if(!gameRunning) {
                ctx.fillStyle = 'white';
                ctx.font = '40px Arial';
                ctx.textAlign = 'center';
                ctx.fillText("GAME OVER", w/2, h/2);
                ctx.font = '20px Arial';
                ctx.fillText("Score: " + score, w/2, h/2 + 40);
                return;
            }

            // Draw Core
            ctx.beginPath();
            ctx.arc(w/2, h/2, CORE_RADIUS, 0, Math.PI*2);
            ctx.fillStyle = `rgba(68, 170, 255, ${health/100})`;
            ctx.shadowBlur = 20 * (health/100);
            ctx.shadowColor = '#44aaff';
            ctx.fill();
            ctx.shadowBlur = 0;

            // Draw Shield
            ctx.save();
            ctx.translate(w/2, h/2);
            ctx.rotate(angle);
            ctx.beginPath();
            ctx.arc(0, 0, ORBIT_RADIUS, -SHIELD_SIZE/2, SHIELD_SIZE/2);
            ctx.strokeStyle = '#00ffaa';
            ctx.lineWidth = 8;
            ctx.lineCap = 'round';
            ctx.shadowBlur = 15;
            ctx.shadowColor = '#00ffaa';
            ctx.stroke();
            ctx.restore();

            // Spawn Meteors
            if(Math.random() < 0.02 + (score/5000)) meteors.push(new Meteor());

            // Update Meteors
            meteors.forEach((m, i) => {
                m.update();
                m.draw();
                
                const dx = m.x - w/2;
                const dy = m.y - h/2;
                const dist = Math.sqrt(dx*dx + dy*dy);

                // Collision with Shield
                if (dist < ORBIT_RADIUS + m.rad && dist > ORBIT_RADIUS - 10) {
                    let mAngle = Math.atan2(dy, dx);
                    // Normalize angles
                    let diff = mAngle - angle;
                    while(diff < -Math.PI) diff += Math.PI*2;
                    while(diff > Math.PI) diff -= Math.PI*2;

                    if(Math.abs(diff) < SHIELD_SIZE/2 + 0.2) {
                        createExplosion(m.x, m.y, '#00ffaa');
                        meteors.splice(i, 1);
                        score += 10;
                        document.getElementById('ui').innerText = "Score: " + score;
                        return;
                    }
                }

                // Collision with Core
                if (dist < CORE_RADIUS) {
                    createExplosion(m.x, m.y, '#ff0000');
                    meteors.splice(i, 1);
                    health -= 20;
                    if(health <= 0) gameRunning = false;
                }
            });

            // Particles
            particles.forEach((p, i) => {
                p.update();
                p.draw();
                if(p.life <= 0) particles.splice(i, 1);
            });
        }
        loop();
    </script>
</body>
</html>
